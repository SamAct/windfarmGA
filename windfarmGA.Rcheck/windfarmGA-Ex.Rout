
R version 3.2.5 (2016-04-14) -- "Very, Very Secure Dishes"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "windfarmGA"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "windfarmGA-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('windfarmGA')
Creating a generic function for 'toJSON' from package 'jsonlite' in package 'googleVis'
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("BaroHoehe")
> ### * BaroHoehe
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: BaroHoehe
> ### Title: Calculates Air Density, Air Pressure and Temperature according
> ###   to the Barometric Height Formula
> ### Aliases: BaroHoehe
> 
> ### ** Examples
> 
> data <- matrix(seq(0,5000,500));
> BaroHoehe(data)
   Height        ph        rh  tempK  tempC
1       0 101325.00 1.2250000 288.15  15.00
2     500  95176.51 1.1506659 284.90  11.75
3    1000  89401.12 1.0808425 281.65   8.50
4    1500  83976.18 1.0152560 278.40   5.25
5    2000  78880.43 0.9536494 275.15   2.00
6    2500  74093.90 0.8957811 271.90  -1.25
7    3000  69597.81 0.8414244 268.65  -4.50
8    3500  65374.56 0.7903660 265.40  -7.75
9    4000  61407.57 0.7424059 262.15 -11.00
10   4500  57681.31 0.6973561 258.90 -14.25
11   5000  54181.16 0.6550399 255.65 -17.50
> plot.ts(BaroHoehe(data))
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("BaroHoehe", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("GoogleChromePlot")
> ### * GoogleChromePlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GoogleChromePlot
> ### Title: Plot the Best Results in Google Chrome
> ### Aliases: GoogleChromePlot
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GoogleChromePlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("GooglePlot")
> ### * GooglePlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GooglePlot
> ### Title: Plot the 'best' Results with Google background map
> ### Aliases: GooglePlot
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GooglePlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("GridFilter")
> ### * GridFilter
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GridFilter
> ### Title: Make a grid from a Polygon
> ### Aliases: GridFilter
> 
> ### ** Examples
> 
> library(sp)
> 
> ## Exemplary input Polygon with 2km x 2km:
> Polygon1 <- Polygon(rbind(c(0, 0), c(0, 2000),
+ c(2000, 2000), c(2000, 0)))
> Polygon1 <- Polygons(list(Polygon1),1);
> Polygon1 <- SpatialPolygons(list(Polygon1))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+ +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(Polygon1) <- CRS(Projection)
> plot(Polygon1,axes=TRUE)
> 
> ## Create a Grid
> GridFilter(Polygon1,200,1,TRUE)
> GridFilter(Polygon1,200,0.5,TRUE)
> GridFilter(Polygon1,400,1,TRUE)
> GridFilter(Polygon1,400,0.5,TRUE)
> 
> 
> ## Examplary irregular input Polygon
> Polygon1 <- Polygon(rbind(c(0, 20), c(0, 200),
+                           c(2000, 2000), c(3000, 0)))
> Polygon1 <- Polygons(list(Polygon1),1);
> Polygon1 <- SpatialPolygons(list(Polygon1))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+ +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(Polygon1) <- CRS(Projection)
> plot(Polygon1,axes=TRUE)
> 
> ## Create a Grid
> GridFilter(Polygon1,200,1,TRUE)
> GridFilter(Polygon1,200,0.5,TRUE)
> GridFilter(Polygon1,200,0.1,TRUE)
> GridFilter(Polygon1,400,1,TRUE)
> GridFilter(Polygon1,400,0.5,TRUE)
> GridFilter(Polygon1,400,0.1,TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GridFilter", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:sp'

> nameEx("HexaTex")
> ### * HexaTex
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: HexaTex
> ### Title: Polygon to Hexagonal Grid Tessellation
> ### Aliases: HexaTex
> 
> ### ** Examples
> 
> library(spatstat)

spatstat 1.42-2       (nickname: 'Barking at Balloons') 
For an introduction to spatstat, type 'beginner'
> library(maptools)
Loading required package: sp
Checking rgeos availability: TRUE
> library(sp)
> Polygon1 <- Polygon(rbind(c(4498482, 2668272), c(4498482, 2669343),
+                           c(4499991, 2669343), c(4499991, 2668272)))
> Polygon1 <- Polygons(list(Polygon1),1);
> Polygon1 <- SpatialPolygons(list(Polygon1))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+ +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(Polygon1) <- CRS(Projection)
> plot(Polygon1,axes=TRUE)
> HexGrid <- HexaTex(Polygon1, 100, TRUE)
> plot(HexGrid[[2]])
> str(HexGrid[[1]])
'data.frame':	71 obs. of  3 variables:
 $ ID: num  1 2 3 4 5 6 7 8 9 10 ...
 $ X : num  4498637 4498937 4499237 4499537 4499837 ...
 $ Y : num  2668288 2668288 2668288 2668288 2668288 ...
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("HexaTex", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:maptools', 'package:sp', 'package:spatstat'

> nameEx("InfluPoints")
> ### * InfluPoints
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: InfluPoints
> ### Title: Find potentially influencing turbines
> ### Aliases: InfluPoints
> 
> ### ** Examples
> 
> library(sp);library(raster)
> ## Exemplary input Polygon with 2km x 2km:
> polYgon <- Polygon(rbind(c(0, 0), c(0, 2000),
+ c(2000, 2000), c(2000, 0)))
> polYgon <- Polygons(list(polYgon),1);
> polYgon <- SpatialPolygons(list(polYgon))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+ +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(polYgon) <- CRS(Projection); plot(polYgon,axes=TRUE)
> 
> t <- as.matrix(cbind(x=runif(10,0,raster::extent(polYgon)[2]),
+      y=runif(10,0,raster::extent(polYgon)[4])))
> wnkl=20
> dist=100000
> dirct=0
> 
> resInfluPoi <- InfluPoints(t,wnkl,dist,polYgon,dirct,plotAngles=TRUE)
> str(resInfluPoi)
List of 10
 $ :'data.frame':	2 obs. of  14 variables:
  ..$ Ax          : num [1:2] 403 124
  ..$ Ay          : num [1:2] 1540 1555
  ..$ Bx          : num [1:2] 531 531
  ..$ By          : num [1:2] 412 412
  ..$ Cx          : num [1:2] 403 124
  ..$ Cy          : num [1:2] 412 412
  ..$ Laenge_C    : num [1:2] 1135 1213
  ..$ Laenge_B    : num [1:2] 1128 1143
  ..$ Laenge_A    : num [1:2] 128 407
  ..$ alpha       : num [1:2] 6.46 19.62
  ..$ betha       : num [1:2] 83.5 70.4
  ..$ gamma       : num [1:2] 90 90
  ..$ Windrichtung: num [1:2] 0 0
  ..$ Punkt_id    : int [1:2] 1 1
 $ :'data.frame':	2 obs. of  14 variables:
  ..$ Ax          : num [1:2] 403 1322
  ..$ Ay          : num [1:2] 1540 1984
  ..$ Bx          : num [1:2] 744 744
  ..$ By          : num [1:2] 353 353
  ..$ Cx          : num [1:2] 403 1322
  ..$ Cy          : num [1:2] 353 353
  ..$ Laenge_C    : num [1:2] 1235 1730
  ..$ Laenge_B    : num [1:2] 1187 1631
  ..$ Laenge_A    : num [1:2] 341 577
  ..$ alpha       : num [1:2] 16 19.5
  ..$ betha       : num [1:2] 74 70.5
  ..$ gamma       : num [1:2] 90 90
  ..$ Windrichtung: num [1:2] 0 0
  ..$ Punkt_id    : int [1:2] 2 2
 $ :'data.frame':	1 obs. of  14 variables:
  ..$ Ax          : num 1322
  ..$ Ay          : num 1984
  ..$ Bx          : num 1146
  ..$ By          : num 1374
  ..$ Cx          : num 1322
  ..$ Cy          : num 1374
  ..$ Laenge_C    : num 635
  ..$ Laenge_B    : num 610
  ..$ Laenge_A    : num 176
  ..$ alpha       : num 16.1
  ..$ betha       : num 73.9
  ..$ gamma       : num 90
  ..$ Windrichtung: num 0
  ..$ Punkt_id    : int 3
 $ :'data.frame':	2 obs. of  14 variables:
  ..$ Ax          : num [1:2] 1797 1889
  ..$ Ay          : num [1:2] 995 1435
  ..$ Bx          : num [1:2] 1816 1816
  ..$ By          : num [1:2] 768 768
  ..$ Cx          : num [1:2] 1797 1889
  ..$ Cy          : num [1:2] 768 768
  ..$ Laenge_C    : num [1:2] 228 671
  ..$ Laenge_B    : num [1:2] 227 667
  ..$ Laenge_A    : num [1:2] 19.6 72.9
  ..$ alpha       : num [1:2] 4.94 6.24
  ..$ betha       : num [1:2] 85.1 83.8
  ..$ gamma       : num [1:2] 90 90
  ..$ Windrichtung: num [1:2] 0 0
  ..$ Punkt_id    : int [1:2] 4 4
 $ :'data.frame':	1 obs. of  14 variables:
  ..$ Ax          : num 0
  ..$ Ay          : num 0
  ..$ Bx          : num 403
  ..$ By          : num 1540
  ..$ Cx          : num 0
  ..$ Cy          : num 0
  ..$ Laenge_C    : num 0
  ..$ Laenge_B    : num 0
  ..$ Laenge_A    : num 0
  ..$ alpha       : num 0
  ..$ betha       : num 0
  ..$ gamma       : num 0
  ..$ Windrichtung: num 0
  ..$ Punkt_id    : int 5
 $ :'data.frame':	1 obs. of  14 variables:
  ..$ Ax          : num 1889
  ..$ Ay          : num 1435
  ..$ Bx          : num 1797
  ..$ By          : num 995
  ..$ Cx          : num 1889
  ..$ Cy          : num 995
  ..$ Laenge_C    : num 449
  ..$ Laenge_B    : num 440
  ..$ Laenge_A    : num 92.6
  ..$ alpha       : num 11.9
  ..$ betha       : num 78.1
  ..$ gamma       : num 90
  ..$ Windrichtung: num 0
  ..$ Punkt_id    : int 6
 $ :'data.frame':	1 obs. of  14 variables:
  ..$ Ax          : num 0
  ..$ Ay          : num 0
  ..$ Bx          : num 1889
  ..$ By          : num 1435
  ..$ Cx          : num 0
  ..$ Cy          : num 0
  ..$ Laenge_C    : num 0
  ..$ Laenge_B    : num 0
  ..$ Laenge_A    : num 0
  ..$ alpha       : num 0
  ..$ betha       : num 0
  ..$ gamma       : num 0
  ..$ Windrichtung: num 0
  ..$ Punkt_id    : int 7
 $ :'data.frame':	1 obs. of  14 variables:
  ..$ Ax          : num 0
  ..$ Ay          : num 0
  ..$ Bx          : num 1322
  ..$ By          : num 1984
  ..$ Cx          : num 0
  ..$ Cy          : num 0
  ..$ Laenge_C    : num 0
  ..$ Laenge_B    : num 0
  ..$ Laenge_A    : num 0
  ..$ alpha       : num 0
  ..$ betha       : num 0
  ..$ gamma       : num 0
  ..$ Windrichtung: num 0
  ..$ Punkt_id    : int 8
 $ :'data.frame':	2 obs. of  14 variables:
  ..$ Ax          : num [1:2] 1146 1322
  ..$ Ay          : num [1:2] 1374 1984
  ..$ Bx          : num [1:2] 1258 1258
  ..$ By          : num [1:2] 760 760
  ..$ Cx          : num [1:2] 1146 1322
  ..$ Cy          : num [1:2] 760 760
  ..$ Laenge_C    : num [1:2] 624 1225
  ..$ Laenge_B    : num [1:2] 614 1224
  ..$ Laenge_A    : num [1:2] 112.5 63.4
  ..$ alpha       : num [1:2] 10.39 2.96
  ..$ betha       : num [1:2] 79.6 87
  ..$ gamma       : num [1:2] 90 90
  ..$ Windrichtung: num [1:2] 0 0
  ..$ Punkt_id    : int [1:2] 9 9
 $ :'data.frame':	1 obs. of  14 variables:
  ..$ Ax          : num 0
  ..$ Ay          : num 0
  ..$ Bx          : num 124
  ..$ By          : num 1555
  ..$ Cx          : num 0
  ..$ Cy          : num 0
  ..$ Laenge_C    : num 0
  ..$ Laenge_B    : num 0
  ..$ Laenge_A    : num 0
  ..$ alpha       : num 0
  ..$ betha       : num 0
  ..$ gamma       : num 0
  ..$ Windrichtung: num 0
  ..$ Punkt_id    : int 10
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("InfluPoints", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:raster', 'package:sp'

> nameEx("PlotWindfarmGA")
> ### * PlotWindfarmGA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: PlotWindfarmGA
> ### Title: Plot the results of an optimization run
> ### Aliases: PlotWindfarmGA
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("PlotWindfarmGA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("PointToLine2")
> ### * PointToLine2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: PointToLine2
> ### Title: Distances between right triangle points
> ### Aliases: PointToLine2
> 
> ### ** Examples
> 
> ## For further calculations only the distances between B-C and A-C
> ## and the angle at A will be needed. B represents the current turbine
> ## and A represents a turbine, that could potentially influence turbine B.
> x <- c(100,100); y <- c(500,500);
> plot(rbind(x,y),col=c("red","blue"),cex=2,pch=20);
> PointToLine2(x,y,TRUE)
      Ax  Ay  Bx  By  Cx  Cy Laenge_C Laenge_B Laenge_A
[1,] 500 500 100 100 500 100 565.6854      400      400
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("PointToLine2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("StartGA")
> ### * StartGA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: StartGA
> ### Title: Create a random initial Population
> ### Aliases: StartGA
> 
> ### ** Examples
> 
> library(sp)
> ## Exemplary input Polygon with 2km x 2km:
> Polygon1 <- Polygon(rbind(c(0, 0), c(0, 2000),
+ c(2000, 2000), c(2000, 0)))
> Polygon1 <- Polygons(list(Polygon1),1);
> Polygon1 <- SpatialPolygons(list(Polygon1))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+ +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(Polygon1) <- CRS(Projection)
> plot(Polygon1,axes=TRUE)
> 
> Grid <- GridFilter(Polygon1,200,1,"TRUE")
> 
> ## Create 5 individuals with 10 wind turbines each.
> firstPop <- StartGA(Grid = Grid[[1]], n = 10, nStart = 5)
> str(firstPop)
List of 5
 $ :'data.frame':	10 obs. of  4 variables:
  ..$ ID : int [1:10] 5 16 22 30 46 49 69 71 78 79
  ..$ X  : num [1:10] 900 1300 700 500 100 ...
  ..$ Y  : num [1:10] 1700 1500 1300 1100 700 ...
  ..$ bin: num [1:10] 1 1 1 1 1 1 1 1 1 1
 $ :'data.frame':	10 obs. of  4 variables:
  ..$ ID : int [1:10] 15 17 28 30 38 54 55 56 60 74
  ..$ X  : num [1:10] 1100 1500 100 500 300 ...
  ..$ Y  : num [1:10] 1500 1500 1100 1100 900 ...
  ..$ bin: num [1:10] 1 1 1 1 1 1 1 1 1 1
 $ :'data.frame':	10 obs. of  4 variables:
  ..$ ID : int [1:10] 2 10 17 21 25 29 30 52 64 76
  ..$ X  : num [1:10] 300 100 1500 500 1300 ...
  ..$ Y  : num [1:10] 1700 1500 1500 1300 1300 ...
  ..$ bin: num [1:10] 1 1 1 1 1 1 1 1 1 1
 $ :'data.frame':	10 obs. of  4 variables:
  ..$ ID : int [1:10] 8 15 30 39 40 48 51 53 60 64
  ..$ X  : num [1:10] 1500 1100 500 500 700 ...
  ..$ Y  : num [1:10] 1700 1500 1100 900 900 ...
  ..$ bin: num [1:10] 1 1 1 1 1 1 1 1 1 1
 $ :'data.frame':	10 obs. of  4 variables:
  ..$ ID : int [1:10] 2 36 41 44 50 52 54 60 62 67
  ..$ X  : num [1:10] 300 1700 900 1500 900 ...
  ..$ Y  : num [1:10] 1700 1100 900 900 700 ...
  ..$ bin: num [1:10] 1 1 1 1 1 1 1 1 1 1
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("StartGA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:sp'

> nameEx("VekWinkelCalc")
> ### * VekWinkelCalc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: VekWinkelCalc
> ### Title: Calculate distances and angles of possibly influencing turbines
> ### Aliases: VekWinkelCalc
> 
> ### ** Examples
> 
> library(sp);library(raster)
> 
> ## Exemplary input Polygon with 2km x 2km:
> polYgon <- Polygon(rbind(c(0, 0), c(0, 2000), c(2000, 2000), c(2000, 0)))
> polYgon <- Polygons(list(polYgon),1);
> polYgon <- SpatialPolygons(list(polYgon))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+                +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(polYgon) <- CRS(Projection); plot(polYgon,axes=TRUE)
> 
> ## Create a random windfarm with 10 turbines
> t <- as.matrix(cbind(x=runif(10,0,raster::extent(polYgon)[2]),
+      y=runif(10,0,raster::extent(polYgon)[4])))
> wnkl <- 20
> distanz <- 100000
> 
> ## Evaluate and plot for every turbine all other potentially influencing turbines
> potInfTur <- list()
> for (i in 1:(length(t[,1]))) {
+   potInfTur[[i]] <- VekWinkelCalc(t = t, o = i, wkl = wnkl,
+                    distanz = distanz, polYgon = polYgon, plotAngles=TRUE);
+ }
> potInfTur
[[1]]
        Ax       Ay       Bx       By       Cx       Cy Laenge_C Laenge_B
3 403.3639 1539.683 531.0173 411.9491 403.3639 411.9491 1134.936 1127.734
8 123.5725 1554.890 531.0173 411.9491 123.5725 411.9491 1213.394 1142.941
  Laenge_A     alpha    betha gamma
3 127.6535  6.458089 83.54191    90
8 407.4448 19.620538 70.37946    90

[[2]]
         Ax       Ay       Bx       By        Cx       Cy Laenge_C Laenge_B
4  403.3639 1539.683 744.2478 353.1135  403.3639 353.1135 1234.564 1186.569
7 1321.5956 1983.812 744.2478 353.1135 1321.5956 353.1135 1729.887 1630.699
  Laenge_A    alpha    betha gamma
4 340.8839 16.02858 73.97142    90
7 577.3478 19.49647 70.50353    90

[[3]]
        Ax       Ay       Bx       By       Cx       Cy Laenge_C Laenge_B
3 1321.596 1983.812 1145.707 1374.046 1321.596 1374.046 634.6275 609.7665
  Laenge_A    alpha    betha gamma
3 175.8889 16.09035 73.90965    90

[[4]]
        Ax        Ay       Bx       By       Cx       Cy Laenge_C Laenge_B
3 1796.779  995.3985 1816.416 768.2074 1796.779 768.2074 228.0381 227.1910
4 1889.351 1435.2370 1816.416 768.2074 1889.351 768.2074 671.0052 667.0296
  Laenge_A    alpha    betha gamma
3  19.6362 4.939820 85.06018    90
4  72.9350 6.240098 83.75990    90

[[5]]
  Ax Ay       Bx       By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma
1  0  0 403.3639 1539.683  0  0        0        0        0     0     0     0

[[6]]
        Ax       Ay       Bx       By       Cx       Cy Laenge_C Laenge_B
3 1889.351 1435.237 1796.779 995.3985 1889.351 995.3985 449.4745 439.8385
  Laenge_A    alpha    betha gamma
3  92.5712 11.88536 78.11464    90

[[7]]
  Ax Ay       Bx       By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma
1  0  0 1889.351 1435.237  0  0        0        0        0     0     0     0

[[8]]
  Ax Ay       Bx       By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma
1  0  0 1321.596 1983.812  0  0        0        0        0     0     0     0

[[9]]
        Ax       Ay       Bx       By       Cx       Cy  Laenge_C  Laenge_B
1 1145.707 1374.046 1258.228 760.0704 1145.707 760.0704  624.2009  613.9753
6 1321.596 1983.812 1258.228 760.0704 1321.596 760.0704 1225.3814 1223.7418
  Laenge_A     alpha    betha gamma
1 112.5214 10.385176 79.61482    90
6  63.3675  2.964228 87.03577    90

[[10]]
  Ax Ay       Bx      By Cx Cy Laenge_C Laenge_B Laenge_A alpha betha gamma
1  0  0 123.5725 1554.89  0  0        0        0        0     0     0     0

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("VekWinkelCalc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:raster', 'package:sp'

> nameEx("WinkelCalc")
> ### * WinkelCalc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: WinkelCalc
> ### Title: Calculates Angles between 3 Points
> ### Aliases: WinkelCalc
> 
> ### ** Examples
> 
>   Aa= as.numeric(cbind(1,1))
>   Bb= as.numeric(cbind(10,3))
>   Cc= as.numeric(cbind(10,1))
>   plot(rbind(Aa,Bb,Cc,Aa), type="b", xlab="x",
+        ylab="y", ylim=c(0,4), xlim=c(0,11));
>   points(x=Aa[1],y=Aa[2],col="green",pch=20);
>   points(x=Bb[1],y=Bb[2],col="red",pch=20);
>   points(x=Cc[1],y=Cc[2],col="blue",pch=20)
>   Angles <- WinkelCalc(Aa,Bb,Cc); Angles
          [,1]
alpha 12.52881
betha 77.47119
gamma 90.00000
>   text(rbind(Aa,Bb,Cc),labels=round(Angles,2),pos=1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("WinkelCalc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("calculateEn")
> ### * calculateEn
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: calculateEn
> ### Title: Calculate Energy Outputs of Individuals
> ### Aliases: calculateEn
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Create a random shapefile
> ##D library(sp)
> ##D Polygon1 <- Polygon(rbind(c(4498482, 2668272), c(4498482, 2669343),
> ##D                     c(4499991, 2669343), c(4499991, 2668272)))
> ##D Polygon1 <- Polygons(list(Polygon1),1);
> ##D Polygon1 <- SpatialPolygons(list(Polygon1))
> ##D Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
> ##D +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> ##D proj4string(Polygon1) <- CRS(Projection)
> ##D plot(Polygon1,axes=TRUE)
> ##D 
> ##D ## Initialize a dummy wind speed raster with value 1
> ##D windraster <-raster::rasterize(Polygon1, raster::raster(
> ##D                                raster::extent(Polygon1),
> ##D                                ncol=180, nrow=180),field=1)
> ##D 
> ##D ## Create a uniform and unidirectional wind data.frame and plot the
> ##D ## resulting wind rose
> ##D data.in <- as.data.frame(cbind(ws=12,wd=0))
> ##D windrosePlot <- plotWindrose(data = data.in, spd = data.in$ws,
> ##D                 dir = data.in$wd, dirres=10, spdmax=20)
> ##D 
> ##D ## Assign the rotor radius and a factor of the radius for grid spacing.
> ##D Rotor= 50; fcrR= 3
> ##D resGrid <- GridFilter(shape = Polygon1,resol = Rotor*fcrR, prop=1,
> ##D                       plotGrid =TRUE)
> ##D ## Assign the indexed data frame to new variable. Element 2 of the list
> ##D ## is the grid, saved as SpatialPolygon.
> ##D resGrid1 <- resGrid[[1]]
> ##D 
> ##D ## Create an initial population with the indexed Grid, 15 turbines and
> ##D ## 100 individuals.
> ##D resStartGA <- StartGA(Grid = resGrid1,n = 15,nStart = 100)
> ##D 
> ##D ## Calculate the expected energy output of the first individual of the
> ##D ## population.
> ##D par(mfrow=c(1,2))
> ##D plot(Polygon1); points(resStartGA[[1]]$X,resStartGA[[1]]$Y, pch=20,cex=2)
> ##D plot(resGrid[[2]],add=TRUE)
> ##D resCalcEn <-calculateEn(sel=resStartGA[[1]],referenceHeight= 50,
> ##D                    RotorHeight= 50, SurfaceRoughness = 0.14,wnkl = 20,
> ##D                    distanz = 100000, resol = 200,dirSpeed = data.in,
> ##D                    RotorR = 50, polygon1 = Polygon1, topograp = FALSE,
> ##D                    windraster = windraster)
> ##D length(resCalcEn)
> ##D str(resCalcEn)
> ##D resCalcEn <- as.data.frame(resCalcEn)
> ##D plot(Polygon1, main = resCalcEn$Energy_Output_Red[[1]])
> ##D points(x = resCalcEn$Bx, y = resCalcEn$By, pch = 20)
> ##D 
> ##D 
> ##D ## Create a variable and multidirectional wind data.frame and plot the
> ##D ## resulting wind rose
> ##D data.in10 <- as.data.frame(cbind(ws=runif(10,1,25),wd=runif(10,0,360)))
> ##D windrosePlot <- plotWindrose(data = data.in10, spd = data.in10$ws,
> ##D                 dir = data.in10$wd, dirres=10, spdmax=20)
> ##D 
> ##D ## Calculate the energy outputs for the first individual with more than one
> ##D ## wind direction.
> ##D resCalcEn <-calculateEn(sel=resStartGA[[1]],referenceHeight= 50,
> ##D                    RotorHeight= 50, SurfaceRoughness = 0.14,wnkl = 20,
> ##D                    distanz = 100000, resol = 200,dirSpeed = data.in10,
> ##D                    RotorR = 50, polygon1 = Polygon1, topograp = FALSE,
> ##D                    windraster = windraster)
> ##D length(resCalcEn)
> ##D str(resCalcEn)
> ##D 
> ##D ## Take Weibull Paramter Raster from the package. (Only for Austria)
> ##D plot(Polygon1); points(resStartGA[[1]]$X,resStartGA[[1]]$Y, pch=20,cex=2)
> ##D plot(resGrid[[2]],add=TRUE)
> ##D resCalcEn <-calculateEn(sel=resStartGA[[1]], referenceHeight=50,
> ##D                         RotorHeight= 50, SurfaceRoughness = 0.14,wnkl = 20,
> ##D                         distanz = 100000, resol = 200,dirSpeed = data.in,
> ##D                         RotorR = 50, polygon1 = Polygon1, topograp = FALSE,
> ##D                         windraster = windraster, weibull = TRUE)
> ##D length(resCalcEn)
> ##D str(resCalcEn)
> ##D resCalcEn <- as.data.frame(resCalcEn)
> ##D plot(Polygon1, main = resCalcEn$Energy_Output_Red[[1]])
> ##D points(x = resCalcEn$Bx, y = resCalcEn$By, pch = 20)
> ##D 
> ##D ## Use your own rasters for the Weibull parameters.
> ##D araster <- "/..pathto../a_param_raster.tif"
> ##D kraster <- "/..pathto../k_param_raster.tif"
> ##D weibullrasters <- list(raster(kraster), raster(araster))
> ##D plot(Polygon1); points(resStartGA[[1]]$X,resStartGA[[1]]$Y, pch=20,cex=2)
> ##D plot(resGrid[[2]],add=TRUE)
> ##D resCalcEn1 <-calculateEn(sel=resStartGA[[1]], referenceHeight= 50,
> ##D                          RotorHeight= 50, SurfaceRoughness = 0.14,wnkl = 20,
> ##D                          distanz = 100000, resol = 200,dirSpeed = data.in,
> ##D                          RotorR = 50, polygon1 = Polygon1, topograp = FALSE,
> ##D                          windraster = windraster, weibull = TRUE,
> ##D                          weibullsrc = weibullrasters)
> ##D length(resCalcEn1)
> ##D str(resCalcEn1)
> ##D resCalcEn1 <- as.data.frame(resCalcEn1)
> ##D plot(Polygon1, main = resCalcEn1$Energy_Output_Red[[1]])
> ##D points(x = resCalcEn1$Bx, y = resCalcEn1$By, pch = 20)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("calculateEn", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("crossover1")
> ### * crossover1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: crossover1
> ### Title: Crossover Method
> ### Aliases: crossover1
> 
> ### ** Examples
> 
>  ## Create two random parents with an index and random binary values
>  Parents <- data.frame(cbind(ID=1:20,bin=sample(c(0,1),20,replace=TRUE,
+                          prob = c(70,30)),bin.1=sample(c(0,1),20,
+                          replace=TRUE,prob = c(30,70))))
>  Parents
   ID bin bin.1
1   1   0     0
2   2   0     1
3   3   0     1
4   4   1     1
5   5   0     1
6   6   1     1
7   7   1     1
8   8   0     1
9   9   0     0
10 10   0     1
11 11   0     1
12 12   0     1
13 13   0     1
14 14   0     1
15 15   1     0
16 16   0     1
17 17   1     0
18 18   1     1
19 19   0     0
20 20   1     1
> 
>  ## Create random Fitness values for both individuals
>  FitParents <- data.frame(cbind(ID=1,Fitness=1000,Fitness.1=20))
>  FitParents
  ID Fitness Fitness.1
1  1    1000        20
> 
>  ## Assign both values to a list
>  CrossSampl <- list(Parents,FitParents);
>  str(CrossSampl)
List of 2
 $ :'data.frame':	20 obs. of  3 variables:
  ..$ ID   : num [1:20] 1 2 3 4 5 6 7 8 9 10 ...
  ..$ bin  : num [1:20] 0 0 0 1 0 1 1 0 0 0 ...
  ..$ bin.1: num [1:20] 0 1 1 1 1 1 1 1 0 1 ...
 $ :'data.frame':	1 obs. of  3 variables:
  ..$ ID       : num 1
  ..$ Fitness  : num 1000
  ..$ Fitness.1: num 20
> 
>  ## Cross their data at equal locations with 2 crossover parts
>  crossover1(CrossSampl, u=1.1, uplimit=300, crossPart = "EQU")
crossover point rate:  2.1
How many parental pairs are at hand:  1
How many permutations are possible:  4
How many permutations are selected:  4 
      [,1] [,2] [,3] [,4]
 [1,]    0    0    0    0
 [2,]    1    1    0    0
 [3,]    1    1    0    0
 [4,]    1    1    1    1
 [5,]    1    1    0    0
 [6,]    1    1    1    1
 [7,]    1    1    1    1
 [8,]    1    1    0    0
 [9,]    0    0    0    0
[10,]    1    1    0    0
[11,]    1    0    1    0
[12,]    1    0    1    0
[13,]    1    0    1    0
[14,]    1    0    1    0
[15,]    0    1    0    1
[16,]    1    0    1    0
[17,]    0    1    0    1
[18,]    1    1    1    1
[19,]    0    0    0    0
[20,]    1    1    1    1
> 
>  ## with 3 crossover parts and equal locations
>  crossover1(CrossSampl, u=2.5, uplimit=300, crossPart = "EQU")
crossover point rate:  3.5
How many parental pairs are at hand:  1
How many permutations are possible:  8
How many permutations are selected:  8 
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
 [1,]    0    0    0    0    0    0    0    0
 [2,]    0    0    0    0    1    1    1    1
 [3,]    0    0    0    0    1    1    1    1
 [4,]    1    1    1    1    1    1    1    1
 [5,]    0    0    0    0    1    1    1    1
 [6,]    1    1    1    1    1    1    1    1
 [7,]    1    1    1    1    1    1    1    1
 [8,]    0    0    1    1    0    0    1    1
 [9,]    0    0    0    0    0    0    0    0
[10,]    0    0    1    1    0    0    1    1
[11,]    0    0    1    1    0    0    1    1
[12,]    0    0    1    1    0    0    1    1
[13,]    0    0    1    1    0    0    1    1
[14,]    0    0    1    1    0    0    1    1
[15,]    1    0    1    0    1    0    1    0
[16,]    0    1    0    1    0    1    0    1
[17,]    1    0    1    0    1    0    1    0
[18,]    1    1    1    1    1    1    1    1
[19,]    0    0    0    0    0    0    0    0
[20,]    1    1    1    1    1    1    1    1
> 
>  ## or with random locations and 5 crossover parts
>  crossover1(CrossSampl, u=4.9, uplimit=300, crossPart = "RAN")
crossover point rate:  5.9
How many parental pairs are at hand:  1
How many permutations are possible:  32
How many permutations are selected:  32 
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [2,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [3,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [4,]    1    1    1    1    1    1    1    1    1     1     1     1     1
 [5,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [6,]    1    1    1    1    1    1    1    1    1     1     1     1     1
 [7,]    1    1    1    1    1    1    1    1    1     1     1     1     1
 [8,]    0    0    0    0    1    1    1    1    0     0     0     0     1
 [9,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[10,]    0    0    0    0    1    1    1    1    0     0     0     0     1
[11,]    0    0    0    0    1    1    1    1    0     0     0     0     1
[12,]    0    0    0    0    1    1    1    1    0     0     0     0     1
[13,]    0    0    1    1    0    0    1    1    0     0     1     1     0
[14,]    0    0    1    1    0    0    1    1    0     0     1     1     0
[15,]    1    1    0    0    1    1    0    0    1     1     0     0     1
[16,]    0    1    0    1    0    1    0    1    0     1     0     1     0
[17,]    1    0    1    0    1    0    1    0    1     0     1     0     1
[18,]    1    1    1    1    1    1    1    1    1     1     1     1     1
[19,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[20,]    1    1    1    1    1    1    1    1    1     1     1     1     1
      [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25]
 [1,]     0     0     0     0     0     0     0     0     0     0     0     0
 [2,]     0     0     0     1     1     1     1     1     1     1     1     1
 [3,]     0     0     0     1     1     1     1     1     1     1     1     1
 [4,]     1     1     1     1     1     1     1     1     1     1     1     1
 [5,]     0     0     0     1     1     1     1     1     1     1     1     1
 [6,]     1     1     1     1     1     1     1     1     1     1     1     1
 [7,]     1     1     1     1     1     1     1     1     1     1     1     1
 [8,]     1     1     1     0     0     0     0     1     1     1     1     0
 [9,]     0     0     0     0     0     0     0     0     0     0     0     0
[10,]     1     1     1     0     0     0     0     1     1     1     1     0
[11,]     1     1     1     0     0     0     0     1     1     1     1     0
[12,]     1     1     1     0     0     0     0     1     1     1     1     0
[13,]     0     1     1     0     0     1     1     0     0     1     1     0
[14,]     0     1     1     0     0     1     1     0     0     1     1     0
[15,]     1     0     0     1     1     0     0     1     1     0     0     1
[16,]     1     0     1     0     1     0     1     0     1     0     1     0
[17,]     0     1     0     1     0     1     0     1     0     1     0     1
[18,]     1     1     1     1     1     1     1     1     1     1     1     1
[19,]     0     0     0     0     0     0     0     0     0     0     0     0
[20,]     1     1     1     1     1     1     1     1     1     1     1     1
      [,26] [,27] [,28] [,29] [,30] [,31] [,32]
 [1,]     0     0     0     0     0     0     0
 [2,]     1     1     1     1     1     1     1
 [3,]     1     1     1     1     1     1     1
 [4,]     1     1     1     1     1     1     1
 [5,]     1     1     1     1     1     1     1
 [6,]     1     1     1     1     1     1     1
 [7,]     1     1     1     1     1     1     1
 [8,]     0     0     0     1     1     1     1
 [9,]     0     0     0     0     0     0     0
[10,]     0     0     0     1     1     1     1
[11,]     0     0     0     1     1     1     1
[12,]     0     0     0     1     1     1     1
[13,]     0     1     1     0     0     1     1
[14,]     0     1     1     0     0     1     1
[15,]     1     0     0     1     1     0     0
[16,]     1     0     1     0     1     0     1
[17,]     0     1     0     1     0     1     0
[18,]     1     1     1     1     1     1     1
[19,]     0     0     0     0     0     0     0
[20,]     1     1     1     1     1     1     1
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("crossover1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("euc.dist")
> ### * euc.dist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: euc.dist
> ### Title: Euclidian Distance between two Points
> ### Aliases: euc.dist
> 
> ### ** Examples
> 
> x=c(200,100)
> y=c(1000,2000)
> euc.dist(x,y)
[1] 2061.553
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("euc.dist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fitness")
> ### * fitness
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fitness
> ### Title: Evaluate the Individual Fitness values
> ### Aliases: fitness
> 
> ### ** Examples
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fitness", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("genAlgo")
> ### * genAlgo
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: genAlgo
> ### Title: Start The Genetic Algorithm for a wind Farm Layout
> ### Aliases: genAlgo
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("genAlgo", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("getRects")
> ### * getRects
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getRects
> ### Title: Get the Grid-IDs from binary matrix
> ### Aliases: getRects
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getRects", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("heatmapGA")
> ### * heatmapGA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: heatmapGA
> ### Title: Plot heatmap of fit grid cells
> ### Aliases: heatmapGA
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("heatmapGA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("leafPlot")
> ### * leafPlot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: leafPlot
> ### Title: Leaflet Plot of a Wind Park
> ### Aliases: leafPlot
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("leafPlot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mutation")
> ### * mutation
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mutation
> ### Title: Mutation Method
> ### Aliases: mutation
> 
> ### ** Examples
> 
> ## Create 4 random individuals with binary values
> a <- cbind(bin=sample(c(0,1),20,replace=TRUE,prob = c(70,30)),
+         bin.1=sample(c(0,1),20,replace=TRUE,prob = c(30,70)),
+         bin.2=sample(c(0,1),20,replace=TRUE,prob = c(30,70)),
+         bin.3=sample(c(0,1),20,replace=TRUE,prob = c(30,70)))
> a
      bin bin.1 bin.2 bin.3
 [1,]   0     0     0     0
 [2,]   0     1     1     1
 [3,]   0     1     0     1
 [4,]   1     1     1     1
 [5,]   0     1     1     1
 [6,]   1     1     0     1
 [7,]   1     1     1     1
 [8,]   0     1     1     0
 [9,]   0     0     0     1
[10,]   0     1     1     0
[11,]   0     1     1     1
[12,]   0     1     0     0
[13,]   0     1     1     1
[14,]   0     1     1     1
[15,]   1     0     1     1
[16,]   0     1     1     0
[17,]   1     0     1     0
[18,]   1     1     1     1
[19,]   0     0     1     0
[20,]   1     1     1     0
> 
> ## Mutate the individuals with a low percentage
> aMut <- mutation(a,0.1)
> ## Check which values are not like the originals
> a==aMut
        bin bin.1 bin.2 bin.3
 [1,]  TRUE  TRUE  TRUE  TRUE
 [2,]  TRUE  TRUE  TRUE  TRUE
 [3,]  TRUE  TRUE  TRUE  TRUE
 [4,]  TRUE  TRUE  TRUE  TRUE
 [5,]  TRUE  TRUE  TRUE  TRUE
 [6,]  TRUE  TRUE  TRUE  TRUE
 [7,]  TRUE  TRUE  TRUE  TRUE
 [8,]  TRUE  TRUE  TRUE  TRUE
 [9,]  TRUE  TRUE  TRUE  TRUE
[10,]  TRUE  TRUE  TRUE  TRUE
[11,]  TRUE  TRUE  TRUE  TRUE
[12,] FALSE  TRUE FALSE  TRUE
[13,]  TRUE  TRUE  TRUE  TRUE
[14,]  TRUE  TRUE  TRUE  TRUE
[15,]  TRUE  TRUE  TRUE  TRUE
[16,]  TRUE  TRUE  TRUE  TRUE
[17,]  TRUE  TRUE  TRUE  TRUE
[18,]  TRUE  TRUE  TRUE  TRUE
[19,]  TRUE  TRUE  TRUE  TRUE
[20,]  TRUE  TRUE  TRUE  TRUE
> 
> ## Mutate the individuals with a high percentage
> aMut <- mutation(a,0.4)
> ## Check which values are not like the originals
> a==aMut
        bin bin.1 bin.2 bin.3
 [1,] FALSE FALSE FALSE FALSE
 [2,]  TRUE  TRUE  TRUE  TRUE
 [3,]  TRUE  TRUE  TRUE  TRUE
 [4,]  TRUE  TRUE  TRUE  TRUE
 [5,]  TRUE  TRUE  TRUE  TRUE
 [6,]  TRUE  TRUE  TRUE  TRUE
 [7,]  TRUE  TRUE  TRUE  TRUE
 [8,] FALSE  TRUE  TRUE FALSE
 [9,]  TRUE  TRUE FALSE  TRUE
[10,] FALSE  TRUE  TRUE  TRUE
[11,]  TRUE  TRUE  TRUE  TRUE
[12,]  TRUE  TRUE FALSE FALSE
[13,]  TRUE  TRUE  TRUE  TRUE
[14,] FALSE  TRUE  TRUE  TRUE
[15,]  TRUE FALSE  TRUE  TRUE
[16,]  TRUE  TRUE  TRUE  TRUE
[17,]  TRUE FALSE  TRUE  TRUE
[18,]  TRUE  TRUE  TRUE  TRUE
[19,]  TRUE FALSE  TRUE  TRUE
[20,]  TRUE  TRUE  TRUE  TRUE
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mutation", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotCloud")
> ### * plotCloud
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotCloud
> ### Title: Plot outputs of all generations with standard deviations
> ### Aliases: plotCloud
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotCloud", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotEvolution")
> ### * plotEvolution
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotEvolution
> ### Title: Plot the evolution of fitness values
> ### Aliases: plotEvolution
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotEvolution", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotResult")
> ### * plotResult
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotResult
> ### Title: Plot the best Results
> ### Aliases: plotResult
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotResult", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotWindrose")
> ### * plotWindrose
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotWindrose
> ### Title: Plot a Windrose
> ### Aliases: plotWindrose
> 
> ### ** Examples
> 
> ## Exemplary Input Wind speed and direction data frame
> # Uniform wind speed and single wind direction
> data.in <- as.data.frame(cbind(ws=12,wd=0))
> windrosePlot <- plotWindrose(data = data.in, spd = data.in$ws,
+    dir = data.in$wd)
> 
> # Random wind speeds and random wind directions
> data.in <- as.data.frame(cbind(ws=sample(1:25,10),wd=sample(1:260,10)))
> windrosePlot <- plotWindrose(data = data.in, spd = data.in$ws,
+    dir = data.in$wd)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotWindrose", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotbeorwor")
> ### * plotbeorwor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotbeorwor
> ### Title: Plot if previous population was better or worse
> ### Aliases: plotbeorwor
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotbeorwor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotfitnessevolution")
> ### * plotfitnessevolution
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotfitnessevolution
> ### Title: Plot the changes of min/mean/max fitness values
> ### Aliases: plotfitnessevolution
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotfitnessevolution", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotparkfitness")
> ### * plotparkfitness
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotparkfitness
> ### Title: Plot the genetic algorithm results
> ### Aliases: plotparkfitness
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotparkfitness", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("readinteger")
> ### * readinteger
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: readinteger
> ### Title: Check Input Crossover Method
> ### Aliases: readinteger
> 
> ### ** Examples
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("readinteger", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("readintegerSel")
> ### * readintegerSel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: readintegerSel
> ### Title: Check Input Selection Method
> ### Aliases: readintegerSel
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("readintegerSel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("selection1")
> ### * selection1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: selection1
> ### Title: Selection Method
> ### Aliases: selection1
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Create a random rectangular shapefile
> ##D library(sp)
> ##D Polygon1 <- Polygon(rbind(c(0, 0), c(0, 2000), c(2000, 2000), c(2000, 0)))
> ##D Polygon1 <- Polygons(list(Polygon1),1);
> ##D Polygon1 <- SpatialPolygons(list(Polygon1))
> ##D Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
> ##D +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> ##D proj4string(Polygon1) <- CRS(Projection)
> ##D plot(Polygon1,axes=TRUE)
> ##D 
> ##D ## Calculate a Grid and an indexed data.frame with coordinates and grid cell Ids.
> ##D Grid1 <- GridFilter(shape = Polygon1,resol = 200,prop = 1);
> ##D Grid <- Grid1[[1]]
> ##D AmountGrids <- nrow(Grid)
> ##D 
> ##D startsel <- StartGA(Grid,10,20);
> ##D wind <- as.data.frame(cbind(ws=12,wd=0))
> ##D fit <- fitness(selection = startsel,referenceHeight = 100, RotorHeight=100,
> ##D                SurfaceRoughness=0.3,Polygon = Polygon1, resol1 = 200,rot=20, dirspeed = wind,
> ##D                srtm_crop="",topograp=FALSE,cclRaster="")
> ##D allparks <- do.call("rbind",fit);
> ##D 
> ##D ## SELECTION
> ##D ## print the amount of Individuals selected. Check if the amount of Turbines is as requested.
> ##D selec6best <- selection1(fit, Grid,2, T, 6, "VAR");
> ##D selec6best <- selection1(fit, Grid,2, T, 6, "FIX");
> ##D selec6best <- selection1(fit, Grid,4, F, 6, "FIX");
> ##D str(selec6best)
> ##D 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("selection1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("splitAt")
> ### * splitAt
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: splitAt
> ### Title: Divide matrices or integer at certain locations
> ### Aliases: splitAt
> 
> ### ** Examples
> 
> splitAt(1:100,20)
[[1]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

[[2]]
 [1]  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38
[20]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57
[39]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76
[58]  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95
[77]  96  97  98  99 100

> splitAt(as.matrix(1:100),20)
[[1]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

[[2]]
 [1]  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38
[20]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57
[39]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76
[58]  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95
[77]  96  97  98  99 100

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("splitAt", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tess2SPdf")
> ### * tess2SPdf
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tess2SPdf
> ### Title: Create a Tesselation from a Polygon
> ### Aliases: tess2SPdf
> 
> ### ** Examples
> 
> library(spatstat)

spatstat 1.42-2       (nickname: 'Barking at Balloons') 
For an introduction to spatstat, type 'beginner'
> library(maptools)
Loading required package: sp
Checking rgeos availability: TRUE
> library(sp)
> Polygon1 <- Polygon(rbind(c(4498482, 2668272), c(4498482, 2669343),
+                           c(4499991, 2669343), c(4499991, 2668272)))
> Polygon1 <- Polygons(list(Polygon1),1);
> Polygon1 <- SpatialPolygons(list(Polygon1))
> Projection <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000
+ +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
> proj4string(Polygon1) <- CRS(Projection)
> plot(Polygon1,axes=TRUE)
> ## Create a hexagonal Tesselation
> HexaGrid <- spatstat::hextess(maptools::as.owin.SpatialPolygons(Polygon1),s = 100)
> plot(HexaGrid)
> HexaGrid
Tessellation
Tiles are windows of general type
83 tiles (irregular windows)
window: rectangle = [4498482, 4499991] x [2668272, 2669343] units
> ## Convert the Tesselation to SpatialPolygons
> Hex2spdf <- tess2SPdf(HexaGrid)
> plot(Hex2spdf)
> Hex2spdf
class       : SpatialPolygons 
features    : 83 
extent      : 4498482, 4499991, 2668272, 2669343  (xmin, xmax, ymin, ymax)
coord. ref. : NA 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tess2SPdf", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:maptools', 'package:sp', 'package:spatstat'

> nameEx("trimton")
> ### * trimton
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: trimton
> ### Title: Adjust the amount of turbines per windfarm
> ### Aliases: trimton
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("trimton", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("windfarmGA")
> ### * windfarmGA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: windfarmGA
> ### Title: Controls the given inputs and initiates an Optimization run
> ### Aliases: windfarmGA
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("windfarmGA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.97 0.45 7.95 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
